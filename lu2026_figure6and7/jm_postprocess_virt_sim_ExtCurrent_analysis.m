% jm_postprocess_virt_sim_ExtCurrent_analysis.m
%% Analyze effects of varying mean virt input current and fluctuations
% Usage: Run directly as a script.
% Explanation:
%       Analyzes the effects of varying mean virt input current, virt input 
%       current noise fluctuations, and FMN mean input current on the set point, 
%       amplitude, and frequency of intrinsic virt oscillations.
%
%       Also includes Multilinear Regression and Principal Component Analysis (PCA)
%       to determine the contribution of parameters to intrinsic frequency.
%
% Inputs:
%       Most recent simulation data file matching pattern: 'simData_ExtCurrent_*.mat'
%           that is generated by jm_automate_virt_sim_vary_ext_current.m
%
% Outputs:
%       Generates heatmaps for intrinsic frequency, amplitude, and set point 
%       across parameter sweeps.
%       Generates example power spectra and time-series trace plots.
%       Generates PCA variance and correlation plots.
%       This is Figure 6b - 6d in Lu et al 2026
%
% Requires:
%       mtspectrumc.m and dependent files from the Chronux toolbox
%       \Shared\Code\Adams_Functions\archive_dependent_scripts.m
%       \Shared\Code\Adams_Functions\plot_vertical_line.m
%       \Shared\Code\Adams_Functions\compute_stats.m
%       \Shared\Code\vIRt-Moore\jm_virt_sim_calc_dominant_freq_spectral.m
%       \Shared\Code\vIRt-Moore\jm_virt_sim_corr_bootci.m
%       \Shared\Code\vIRt-Moore\jm_annotate_imageplot_pixel_outlines.m
%       \Shared\Code\vIRt-Moore\jm_annotate_imageplot_pixel_values_text.m
%
% File History:
% 2025-12-12 Created by Jeff Moore
% 2026-01-09 Updated for new data set
% 2026-01-13 Reorganized and reannotated by Gemini
% 2026-01-14 Fixed minSetPtLimit to 25 and maxSetPtLimit to 75
% 2026-01-14 Compute full width at half maximum for the Example Spectra, with value shown in legend labels
% 2026-01-14 Updated FWHM plotting to use staggered double arrows to avoid overlap
% 2026-01-15 Added backward compatibility for fields by Gemini
% 2026-01-16 Now archives dependent scripts
% 2026-01-16 Now detects input files using pattern matching
% 2026-01-16 Added backward compatibility for variable names (snake to camel)
% 2026-01-23 Added calculation of mean and std for FWHM
% 2026-01-25 Added vertical line for intrinsic freq and updated legend format by Gemini
% 2026-01-25 Auto-detect indicesToPlot3 monotonically and plot separate figures for spectra sets by Gemini
% 2026-01-25 Implemented parfor loop for metric calculation and validity checking by Gemini
% 2026-01-25 Optimized masking using linear indices and moved logging to serial loop by Gemini
% 2026-01-25 Refactored FWHM to compute exactly once inside parfor and store fLeft/fRight by Gemini
% 2026-01-25 Pre-extracted effectorVec using serial loops to resolve parfor OOM error by Gemini
% 2026-01-25 Updated Step 2 and Step 3 ranking logic for indicesToPlot3 selection by Gemini
% 2026-01-25 Updated Step 1 (rounding), Step 2 (reporting), and Step 3 (ranking weights) for indicesToPlot3 by Gemini
% 2026-01-25 Added multilinear regression analysis section for valid data by Gemini
% 2026-01-25 Updated logging format and Step 2/3 ranking logic (hierarchical sort) by Gemini
% 2026-01-25 Updated maxAmpLimit from 25 to 30
% 2026-01-26 Added PCA, Shuffle Test, and Bootstrap analysis from Jeff's code by Gemini

%% Hard-coded parameters
% Define output directory
outDir = pwd;

% Define file pattern for simulation data (assumed to be in outDir)
simDataFilePattern = 'simData_ExtCurrent_*.mat';

% Define file paths for dependencies
nameChronuxFile = 'mtspectrumc.m';
scriptDir = fileparts(mfilename('fullpath'));
pathChronux = fullfile(scriptDir, 'chronux_2_12_annotated');

% Define output directory for figures
figureDir = fullfile(outDir, 'Figures');

% Define Chronux spectral analysis parameters
%   Note: traces are noisy with noisy inputs, need NW = 7.5 or 15
%           7.5 = 0.5 Hz resolution for 15 sec
%           15 = 1 Hz resolution for 15 sec
NW = 15;                        % Time half-bandwidth product
params.tapers = [NW, floor((2 * NW) - 1)];
params.pad    = -1;             % -1 default (no padding)
params.fpass  = [0, 15];        % Frequency pass band
params.err    = [2, 0.05];      % Error calculation [Jackknife, p-value]
params.trialave = 1;            % Average over trials

% Define analysis parameters
downsampleFactor = 10;          % Downsampling factor for spectral calculation

% Define filtering limits for valid oscillation detection
minAmpLimit = 15;
maxAmpLimit = 30;
minSetPtLimit = 25;
maxSetPtLimit = 75;

% Define plotting ranges for heatmaps
rangeFreq = [5, 10];
rangeAmp = [0, 150];
rangeSetPt = [0, 150];

% Define plotting parameters for example traces
timeWinExample = [10, 14];
yLimitsExample = [40, 180] / 2;
orderExample1 = 2;
orderExample2 = 8;

% Define target intrinsic frequencies (Hz)
targetIntrinsicFreq = [5.5; 6.0; 6.6; 7.1; 7.5; 7.8; 8.4; 8.9];

% Define indices of interest (i, j, k) to plot specific examples in the example spectra
indicesToPlot1 = [
    2, 2, 3;        % ~6.1 Hz for twister run
    3, 4, 4;        % ~6.5 Hz for twister run
    6, 8, 5;        % ~7.0 Hz for twister run
    8, 8, 6;        % ~7.5 Hz for twister run
    10, 9, 8;       % ~7.8 Hz for twister run
    12, 12, 9;      % ~8.4 Hz for twister run
    11, 10, 6;      % ~8.4 Hz for twister run
    14, 12, 8       % ~8.9 Hz for twister run
];
indicesToPlot2 = [
    1, 4, 1; ...    % ~5.5 Hz for twister run
    3, 5, 2; ...    % ~6.0 Hz for twister run
    4, 6, 3; ...    % ~6.6 Hz for twister run
    5, 6, 3; ...    % ~7.1 Hz for twister run
    6, 7, 4; ...    % ~7.5 Hz for twister run
    10, 9, 6; ...   % ~7.8 Hz for twister run
    11, 10, 6; ...  % ~8.4 Hz for twister run
    14, 12, 8; ...  % ~8.9 Hz for twister run
];
% indicesToPlot3 will be calculated automatically below

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Preparation
% If not exist, add path for the required function from the Chronux package
if ~exist(nameChronuxFile, 'file')
    if exist(pathChronux, 'dir')
        addpath(pathChronux);
        fprintf('%s and dependent files found and added to path.\n', nameChronuxFile);
    else
        warning('%s and dependent files not found at: %s. Spectral analysis may fail.', nameChronuxFile, pathChronux);
    end
end

% Create figure directory if it doesn't exist
if ~exist(figureDir, 'dir')
    mkdir(figureDir);
    fprintf('Created figure directory: %s\n', figureDir);
end

% Start logging to file
logFile = fullfile(figureDir, 'analysis_log_ExtCurrent_analysis.txt');
if exist(logFile, 'file')
    delete(logFile);
end
diary(logFile);
fprintf('Log started at %s\n', char(datetime('now')));
fprintf('------------------------------------------------------------\n');

% Copy this script and its dependencies to the output directory
archive_dependent_scripts(mfilename, 'OutFolder', outDir);

% Find and load simulation data
fileList = dir(fullfile(outDir, simDataFilePattern));
if isempty(fileList)
    error('No files found matching pattern: %s', simDataFilePattern);
end

% Sort by date (descending) to get the most recent file
[~, idx] = sort([fileList.datenum], 'descend');
simDataFile = fullfile(fileList(idx(1)).folder, fileList(idx(1)).name);
fprintf('Auto-detected most recent data file: %s\n', simDataFile);

% Load the simulation data from the specified MAT file
fprintf('Loading data from %s...\n', simDataFile);
load(simDataFile);
% Note: Loading simDataFile introduces 'output', 
%           'vIRtInputCurrents' or 'vIRt_input_currents', 
%           'vIRtStdTimes' or 'vIRt_stdTimes', 
%           'fmnInputCurrents' or 'FMN_input_currents' into workspace
fprintf('Data loaded!\n');

% Backwards Compatibility: Variable Names (snake_case to camelCase)
if exist('vIRt_input_currents', 'var') && ~exist('vIRtInputCurrents', 'var')
    vIRtInputCurrents = vIRt_input_currents;
end
if exist('vIRt_stdTimes', 'var') && ~exist('vIRtStdTimes', 'var')
    vIRtStdTimes = vIRt_stdTimes;
end
if exist('FMN_input_currents', 'var') && ~exist('fmnInputCurrents', 'var')
    fmnInputCurrents = FMN_input_currents;
end

% Ensure required variables exist
if ~exist('vIRtInputCurrents', 'var') || ~exist('vIRtStdTimes', 'var') || ~exist('fmnInputCurrents', 'var')
    error('Required variables (vIRtInputCurrents, vIRtStdTimes, fmnInputCurrents) not found in loaded file.');
end

%% Do the job
% 1. Data Extraction (Serial) & Metrics Calculation (Parallelized)

% Determine the number of steps for each parameter sweep
nVirtInputCurrents = length(vIRtInputCurrents);
nVirtStdTimes = length(vIRtStdTimes);
nFmnInputCurrents = length(fmnInputCurrents);

% Total simulation count
totalSims = nVirtInputCurrents * nVirtStdTimes * nFmnInputCurrents;

% Initialize flattened arrays for parallel processing
% parfor requires sliced output or flattened arrays
flatIntrinsicFreq = zeros(totalSims, 1);
flatIntrinsicAmp = zeros(totalSims, 1);
flatIntrinsicSetPt = zeros(totalSims, 1);
flatIntrinsicFWHM = zeros(totalSims, 1);
flatFLeft = zeros(totalSims, 1);
flatFRight = zeros(totalSims, 1);
flatIsMaskValid = false(totalSims, 1);

fprintf('\n--- Pre-extracting vectors for parallel pool (Serial) ---\n');

% Pre-allocate cell array to store only necessary data for workers
simulationDataList = cell(totalSims, 1);

% Serial Extraction Loop
% Move extraction outside parfor to avoid "Out of Memory during deserialization"
for idx = 1:totalSims
    % Convert linear index to subscripts
    [i, j, k] = ind2sub([nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents], idx);
    
    % Access the large structure
    simStruct = output.intrinsicDefault.vIRtInput(i).vIRtStdTime(j).FMNInput(k);
    
    % Extract only what is needed for the calculation
    extractedData = struct();
    
    % 1. Time step
    extractedData.dt = simStruct.params.dt / 1000; % Convert ms to s
    
    % 2. Steady State Vector
    effectorVecRaw = simStruct.effectorVec;
    extractedData.effectorSteadyState = effectorVecRaw(ceil(end/2):end);
    
    % 3. Amplitude Probe (Handle Backwards Compatibility here)
    if isfield(simStruct.analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
        extractedData.intrinsicAmpProbe = simStruct.analysis.whisk.meanFirstPeakAmplitudeSecondHalf;
    elseif isfield(simStruct.analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
        extractedData.intrinsicAmpProbe = simStruct.analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
    else
        error('Amplitude field not found in analysis struct.');
    end
    
    % Store in cell array
    simulationDataList{idx} = extractedData;
end

fprintf('Data extraction complete. Starting parallel analysis...\n');
fprintf('\n--- Calculation Loop Started (Parallel) ---\n');

% Iterate through all combinations using linear indexing for parfor
% NOTE: Do NOT reference 'output' inside this loop. Use simulationDataList.
parfor idx = 1:totalSims
    
    % Retrieve pre-extracted data
    simData = simulationDataList{idx};
    
    % Unpack variables
    dt = simData.dt;
    effectorSteadyState = simData.effectorSteadyState;
    intrinsicAmpProbe = simData.intrinsicAmpProbe;
    
    % Calculate spectral metrics (Frequency and Set Point)
    [intrinsicFreq, ~, intrinsicSetPt] = ...
        jm_virt_sim_calc_dominant_freq_spectral(effectorSteadyState, dt, downsampleFactor, params);
    
    % Calculate FWHM using mtspectrumc (executed once here)
    % Create local params structure to update Fs
    localParams = params;
    localParams.Fs = (1 / dt) / downsampleFactor;
    effectorDownsampled = effectorSteadyState(1:downsampleFactor:end);
    
    % Compute spectrum
    [S, f] = mtspectrumc(effectorDownsampled - mean(effectorDownsampled), localParams);
    
    % Compute FWHM and edge frequencies using helper function
    [fwhm, fLeft, fRight] = calc_fwhm_from_spectrum(S, f);
    
    % Check Validity Mask (Decide whether set is within filter)
    isValid = true;
    if intrinsicAmpProbe < minAmpLimit || ...
       intrinsicAmpProbe > maxAmpLimit || ...
       intrinsicSetPt < minSetPtLimit || ...
       intrinsicSetPt > maxSetPtLimit
        isValid = false;
    end
    
    % Store results
    flatIntrinsicFreq(idx) = intrinsicFreq;
    flatIntrinsicAmp(idx) = intrinsicAmpProbe;
    flatIntrinsicSetPt(idx) = intrinsicSetPt;
    flatIntrinsicFWHM(idx) = fwhm;
    flatFLeft(idx) = fLeft;
    flatFRight(idx) = fRight;
    flatIsMaskValid(idx) = isValid;
end

% 2. Log Results (Serial) and Shape Output Arrays

fprintf('Calculation complete. Printing log results...\n');
fprintf('Format: [Sim Index] (i,j,k)|(mu,sigma,F) -> Freq (Hz) | Amp (a.u.) | SetPt (a.u.) | FWHM (Hz) | Valid?\n');

for idx = 1:totalSims
    [i, j, k] = ind2sub([nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents], idx);
    
    % Retrieve parameter values for logging
    valMu = vIRtInputCurrents(i);
    valSigma = vIRtStdTimes(j);
    valF = fmnInputCurrents(k);
    
    if flatIsMaskValid(idx)
        validString = 'YES';
    else
        validString = 'NO';
    end
    
    fprintf('[Sim %d] (%d,%d,%d)|(%.2f,%.2f,%.2f) -> %.2f Hz | %.2f | %.2f | %.2f Hz | Valid: %s\n', ...
        idx, i, j, k, valMu, valSigma, valF, ...
        flatIntrinsicFreq(idx), flatIntrinsicAmp(idx), ...
        flatIntrinsicSetPt(idx), flatIntrinsicFWHM(idx), validString);
end

% Reshape results back to 3D arrays for subsequent processing
intrinsicFreqAll = reshape(flatIntrinsicFreq, [nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents]);
intrinsicAmpAll = reshape(flatIntrinsicAmp, [nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents]);
intrinsicSetPtAll = reshape(flatIntrinsicSetPt, [nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents]);
intrinsicFWHMAll = reshape(flatIntrinsicFWHM, [nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents]);
intrinsicFLeftAll = reshape(flatFLeft, [nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents]);
intrinsicFRightAll = reshape(flatFRight, [nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents]);

% 3. Filter results using Valid Linear Indices

% Identify valid linear indices
validIndices = find(flatIsMaskValid);

% Initialize "InLimits" arrays with NaNs
intrinsicFreqsInLimits = NaN(size(intrinsicFreqAll));
intrinsicAmpsInLimits = NaN(size(intrinsicAmpAll));
intrinsicSetPtsInLimits = NaN(size(intrinsicSetPtAll));

% Populate only the valid indices
intrinsicFreqsInLimits(validIndices) = intrinsicFreqAll(validIndices);
intrinsicAmpsInLimits(validIndices) = intrinsicAmpAll(validIndices);
intrinsicSetPtsInLimits(validIndices) = intrinsicSetPtAll(validIndices);

% 4. Reconstruct Predictor Vectors for Valid Data (Used for Regression and PCA)
[subI, subJ, subK] = ind2sub([nVirtInputCurrents, nVirtStdTimes, nFmnInputCurrents], (1:totalSims)');

% Ensure source vectors are column vectors
vecMu = vIRtInputCurrents(:);
vecSigma = vIRtStdTimes(:);
vecF = fmnInputCurrents(:);

% Map subscripts to physical values
flatMu = vecMu(subI);
flatSigma = vecSigma(subJ);
flatF = vecF(subK);

% Create subsets for valid data only
validIndicesMask = flatIsMaskValid;

yDataValid = flatIntrinsicFreq(validIndicesMask);
xMuValid = flatMu(validIndicesMask);
xSigmaValid = flatSigma(validIndicesMask);
xFValid = flatF(validIndicesMask);

%% Multilinear Regression Analysis
% Model: Intrinsic Frequency ~ mu (vIRtInputCurrent) + sigma (vIRtStdTime) + F (fmnInputCurrent)

fprintf('\n--- Multilinear Regression Analysis ---\n');

% Perform regression
if exist('fitlm', 'file')
    % Create table
    regTable = table(xMuValid, xSigmaValid, xFValid, yDataValid, 'VariableNames', {'Mu', 'Sigma', 'F', 'IntrinsicFreq'});
    
    % Fit linear model
    linearModel = fitlm(regTable, 'IntrinsicFreq ~ Mu + Sigma + F');
    
    % Display results
    disp(linearModel);
else
    % Fallback using regress (Signal Processing / Stats toolbox basic)
    fprintf('fitlm function not found. Using regress.\n');
    XReg = [ones(length(yDataValid), 1), xMuValid, xSigmaValid, xFValid];
    [b, ~, ~, ~, stats] = regress(yDataValid, XReg);
    
    fprintf('R-squared: %.4f\n', stats(1));
    fprintf('P-value (model): %.4e\n', stats(3));
    fprintf('Coefficients:\n');
    fprintf('Intercept: %.4f\n', b(1));
    fprintf('Mu: %.4f\n', b(2));
    fprintf('Sigma: %.4f\n', b(3));
    fprintf('F: %.4f\n', b(4));
end

%% Principal Component Analysis (PCA) & Bootstrap Analysis
% Added 2026-01-26
% Reformat matrix as observations of [mu, sigma, F] vs [intrinsicFreq] for PCA
% Using valid data extracted above

fprintf('\n--- PCA, Shuffle Test, and Bootstrap Analysis ---\n');

% Prepare Data Matrix X = [mu, sigma, F] (N x 3) and y = IntrinsicFreq
X = [xMuValid, xSigmaValid, xFValid];
y = yDataValid;

% Z-score the input matrix for PCA
xZscored = zscore(X);

% 1. Baseline PCA & Sign Alignment
[coeffOrig, scoreOrig, latentOrig] = pca(xZscored);

% Parameters for stats
numIter = 10000; % Iterations for both Shuffle and Bootstrap
[N, P] = size(xZscored);

actualVarExp  = latentOrig' / sum(latentOrig);
fprintf('Actual Variance Explained by PCs: %s\n', mat2str(actualVarExp, 3));

% 2. Shuffle Test (Permutation) for PC Significance
% Null Hypothesis: No correlation between parameters exists.
fprintf('Running Shuffle Test (%d iterations)...\n', numIter);
nullVars = zeros(numIter, 3);
for i = 1:numIter
    xShuffled = zeros(N, P);
    for col = 1:P
        xShuffled(:,col) = xZscored(randperm(N), col);
    end
    [~, ~, lShuff] = pca(xShuffled);
    nullVars(i,:) = lShuff' ./ sum(lShuff);
end

pPCVariance = zeros(1, P);
for i=1:P
    pPCVariance(i) = mean(nullVars(:,i) >= actualVarExp(i));
end

% 3. Bootstrap for Loading Confidence Intervals
fprintf('Running Bootstrap Analysis (%d iterations)...\n', numIter);
bootVars = zeros(numIter, P);
bootRci = zeros(numIter, P);
bootRciFi = zeros(numIter, 1);

for i = 1:numIter
    % Resample indices with replacement
    idxResamp = randi(N, N, 1);
    
    xResamp = X(idxResamp, :);
    yResamp = y(idxResamp);
    
    % Perform PCA on resampled data
    [~, scoreBoot, lBoot] = pca(zscore(xResamp));
    
    bootVars(i,:) = lBoot' / sum(lBoot); % all PCs
    
    % Correlation with 1st PC
    rciBoot = corr(xResamp, scoreBoot(:,1)); % [mu sigma F]
    rciFiBoot = corr(yResamp, scoreBoot(:,1)); % IntrinsicFreq
    
    bootRci(i,:) = rciBoot; 
    bootRciFi(i) = rciFiBoot;
end

% Calculate Confidence Intervals
varsCi = [prctile(bootVars, 2.5); prctile(bootVars, 97.5)];
rci = [prctile(bootRci, 2.5); prctile(bootRci, 97.5)];
rciMu = rci(:,1);
rciS = rci(:,2);
rciF = rci(:,3);
rciFi = [prctile(bootRciFi, 2.5); prctile(bootRciFi, 97.5)];

% 4. Correlation with each axis and frequency using helper function
% Calculates corr coeffs with each parameter and PC1
[rMu, pMu] = jm_virt_sim_corr_bootci(scoreOrig(:,1), X(:,1), numIter);
[rS, pS] = jm_virt_sim_corr_bootci(scoreOrig(:,1), X(:,2), numIter);
[rF, pF] = jm_virt_sim_corr_bootci(scoreOrig(:,1), X(:,3), numIter);
[rFi, pFi] = jm_virt_sim_corr_bootci(scoreOrig(:,1), y, numIter);

% --- Display Results (PCA) ---

figure; 
% Subplot 1: Variance Explained
subplot(3,1,1); hold on;
plot(1:P, actualVarExp, 'ko-');
plot(1:P, varsCi(1,:), 'k.');
plot(1:P, varsCi(2,:), 'k.');
xlabel('PC');
ylabel('Variance explained')
box off;
xlim([0.5 3.5])
ylim([0 1])
text(0.75, 1, 'p:');
text(1:P, ones(1,P), num2str(pPCVariance'))
title('PCA Analysis: Variance Explained')

% Subplot 2: Freq vs PC1
subplot(3,1,2); hold on
plot(scoreOrig(:,1), y, '.')
xlabel('PC1');
ylabel('Intrinsic Frequency')

% Subplot 3: Correlations
subplot(3,1,3); hold on
plot(1:P+1, [rMu rS rF rFi], 'ko')
plot(1:P+1, [rciMu(1) rciS(1) rciF(1) rciFi(1)], 'k.')
plot(1:P+1, [rciMu(2) rciS(2) rciF(2) rciFi(2)], 'k.')
xlabel('Parameter (1:Mu, 2:Sigma, 3:F, 4:Freq)');
ylabel('Correlation with PC1')
box off;
xlim([0.5 4.5])
ylim([-1 1])
rpvals = [pMu pS pF pFi];
text(1:P+1, ones(1,P+1), num2str(rpvals'))
text(0.75, 1, 'p:');
title('Correlation of Parameters with PC1')

% Save PCA Figure
saveas(gcf, fullfile(figureDir, 'fig_virt_sim_ExtCurrent_analysis_PCA.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_sim_ExtCurrent_analysis_PCA.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_sim_ExtCurrent_analysis_PCA.eps'), 'epsc');


%% Calculate best indices for indicesToPlot3
fprintf('\n--- Calculating Best Indices for indicesToPlot3 ---\n');

% Step 1: Gather candidates with intrinsic frequencies rounded to target
% Criteria: round(intrinsicFreq, 1) == target
numTargets = length(targetIntrinsicFreq);
allCandidates = cell(numTargets, 1);

for iFreq = 1:numTargets
    target = targetIntrinsicFreq(iFreq);
    
    % Round the filtered frequency matrix to 1 decimal place
    roundedFreqs = round(intrinsicFreqsInLimits, 1);
    
    % Find linear indices matching the target exactly after rounding
    linearIndices = find(roundedFreqs == target);
    
    % Convert linear indices to subscripts [i, j, k]
    [subI, subJ, subK] = ind2sub(size(roundedFreqs), linearIndices);
    
    % Store all candidates for this target frequency
    allCandidates{iFreq} = [subI, subJ, subK];
    
    fprintf('Target %.2f Hz: Found %d candidates (after rounding)\n', ...
        target, length(subI));
end

% Step 2: Check Monotonicity of Mean and Min vIRtInputCurrent
fprintf('\n--- Checking Monotonicity of vIRtInputCurrent (Min and Mean) ---\n');

meanMuValues = NaN(numTargets, 1);
minMuValues = NaN(numTargets, 1);

for iFreq = 1:numTargets
    target = targetIntrinsicFreq(iFreq);
    candidates = allCandidates{iFreq}; % [n x 3] matrix
    
    if isempty(candidates)
        warning('No candidates for target %.2f Hz', target);
        continue;
    end
    
    % Find linear indices to retrieve metrics
    candLinIdx = sub2ind(size(intrinsicFreqAll), candidates(:,1), candidates(:,2), candidates(:,3));
    
    candAmps = intrinsicAmpAll(candLinIdx);
    candSetPts = intrinsicSetPtAll(candLinIdx);
    candMuVals = vIRtInputCurrents(candidates(:, 1))';
    
    fprintf('Target %.2f Hz - Candidate Details:\n', target);
    for c = 1:length(candLinIdx)
        fprintf('   Candidate (%d,%d,%d)|(%.2f,%.2f,%.2f) -> Amp: %.2f | SetPt: %.2f | vIRtInput: %.2f pA\n', ...
            candidates(c,1), candidates(c,2), candidates(c,3), ...
            vIRtInputCurrents(candidates(c,1)), ...
            vIRtStdTimes(candidates(c,2)), ...
            fmnInputCurrents(candidates(c,3)), ...
            candAmps(c), candSetPts(c), candMuVals(c));
    end

    % Calculate min and mean vIRtInputCurrent for this group
    minMuValues(iFreq) = min(candMuVals);
    meanMuValues(iFreq) = mean(candMuVals);
    
    fprintf('   => Group Min vIRtInputCurrent = %.4f pA\n', minMuValues(iFreq));
    fprintf('   => Group Mean vIRtInputCurrent = %.4f pA\n', meanMuValues(iFreq));
end

% Check if values are strictly monotonically increasing (ignoring NaNs)
validMask = ~isnan(minMuValues);
validMinMu = minMuValues(validMask);
validMeanMu = meanMuValues(validMask);

if ~all(diff(validMinMu) > 0)
    warning('Minimum vIRtInputCurrent values are NOT strictly monotonically increasing across target frequencies!');
end

if ~all(diff(validMeanMu) > 0)
    warning('Mean vIRtInputCurrent values are NOT strictly monotonically increasing across target frequencies!');
end

if all(diff(validMinMu) > 0) && all(diff(validMeanMu) > 0)
    fprintf('Success: Both Minimum and Mean vIRtInputCurrent values are strictly monotonically increasing.\n');
end

% Step 3: Select one set for each target based on Hierarchical Ranking
% Priorities:
%   1) rankMu (lower vIRtInputCurrent is better)
%   2) rankFWHM (lower is better)
%   3) rankDiffSetPt: Abs Diff(SetPt, TargetSetPt) (lower is better)
%           TargetSetPt = (minSetPtLimit + maxSetPtLimit) / 2
%   4) rankDiffAmp: Abs Diff(Amp, TargetAmp) (lower is better)
%           TargetAmp = (minAmpLimit + maxAmpLimit) / 2
%   5) rankDiffMid: Abs Diff(Midpoint, TargetFreq) (lower is better)

fprintf('\n--- Selecting Best Indices (Priority: Mu > FWHM > SetPt > Amp) ---\n');

% Define targets for optimization
targetSetPt = (minSetPtLimit + maxSetPtLimit) / 2;
targetAmp = (minAmpLimit + maxAmpLimit) / 2;
fprintf('Optimization Targets -> SetPt: %.2f, Amp: %.2f\n', targetSetPt, targetAmp);

indicesToPlot3 = zeros(numTargets, 3);

for iFreq = 1:numTargets
    target = targetIntrinsicFreq(iFreq);
    candidates = allCandidates{iFreq}; % [n x 3] matrix of subscripts
    
    if isempty(candidates)
        warning('No candidates found for target %.2f Hz', target);
        continue;
    end
    
    % Find linear indices for the candidates
    candLinIdx = sub2ind(size(intrinsicFWHMAll), candidates(:,1), candidates(:,2), candidates(:,3));
    
    % Retrieve metrics
    candFLefts = intrinsicFLeftAll(candLinIdx);
    candFRights = intrinsicFRightAll(candLinIdx);
    candFWHMs = intrinsicFWHMAll(candLinIdx); 
    candAmps = intrinsicAmpAll(candLinIdx);
    candSetPts = intrinsicSetPtAll(candLinIdx);
    candMuVals = vIRtInputCurrents(candidates(:, 1))';
    
    % Calculate derived metrics
    midpointVals = (candFLefts + candFRights) / 2;
    distToTargetFreq = abs(midpointVals - target);  % rankDiffMid
    distToTargetSetPt = abs(candSetPts - targetSetPt); % rankDiffSetPt
    distToTargetAmp = abs(candAmps - targetAmp);       % rankDiffAmp
    
    numCand = size(candidates, 1);

    % --- Calculate Ranks (1 = Best) ---
    % Using 'unique' logic for ranks isn't strictly necessary for sorting, 
    % but we compute them to display as requested.
    
    % Rank 1: vIRtInputCurrent (Mu) (1 = Smallest/Best)
    [~, sortIdxMu] = sort(candMuVals);
    rankMu = zeros(numCand, 1);
    rankMu(sortIdxMu) = (1:numCand)';
    
    % Rank 2: FWHM (1 = Smallest/Best)
    [~, sortIdxFWHM] = sort(candFWHMs);
    rankFWHM = zeros(numCand, 1);
    rankFWHM(sortIdxFWHM) = (1:numCand)';
    
    % Rank 3: Set Point Diff (1 = Smallest/Best)
    [~, sortIdxSetPt] = sort(distToTargetSetPt);
    rankDiffSetPt = zeros(numCand, 1);
    rankDiffSetPt(sortIdxSetPt) = (1:numCand)';
    
    % Rank 4: Amp Diff (1 = Smallest/Best)
    [~, sortIdxAmp] = sort(distToTargetAmp);
    rankDiffAmp = zeros(numCand, 1);
    rankDiffAmp(sortIdxAmp) = (1:numCand)';
    
    % Rank 5: Midpoint Frequency Diff (1 = Smallest/Best)
    [~, sortIdxMid] = sort(distToTargetFreq);
    rankDiffMid = zeros(numCand, 1);
    rankDiffMid(sortIdxMid) = (1:numCand)';
    
    % --- Print Stats and Ranks for All Candidates ---
    fprintf('Target %.2f Hz - Analyzing %d candidates:\n', target, numCand);
    for c = 1:numCand
        fprintf('    (%d,%d,%d)|(%.2f,%.2f,%.2f) -> Mu: %.2f (R%d), FWHM: %.2f (R%d), SetPtDiff: %.2f (R%d), AmpDiff: %.2f (R%d), MidDiff: %.4f (R%d)\n', ...
            candidates(c,1), candidates(c,2), candidates(c,3), ...
            vIRtInputCurrents(candidates(c,1)), ...
            vIRtStdTimes(candidates(c,2)), ...
            fmnInputCurrents(candidates(c,3)), ...
            candMuVals(c), rankMu(c), ...
            candFWHMs(c), rankFWHM(c), ...
            distToTargetSetPt(c), rankDiffSetPt(c), ...
            distToTargetAmp(c), rankDiffAmp(c), ...
            distToTargetFreq(c), rankDiffMid(c));
    end

    % --- Select Best Candidate ---
    % Sort strictly by priority:
    % 1. rankMu
    % 2. rankFWHM
    % 3. rankDiffSetPt
    % 4. rankDiffAmp
    % Note: Using the raw values for sorting is equivalent to sorting by rank 
    % and handles exact value ties naturally.
    scoreMatrix = [candMuVals, candFWHMs, distToTargetSetPt, distToTargetAmp];
    [~, bestSortOrder] = sortrows(scoreMatrix);
    
    bestIdxLocal = bestSortOrder(1);
    bestCandidate = candidates(bestIdxLocal, :);
    
    % Store the selected best candidate
    indicesToPlot3(iFreq, :) = bestCandidate;
    
    % --- Print Selection Details ---
    fprintf('  -> Selected: (%d,%d,%d)|(%.2f,%.2f,%.2f)\n', ...
        bestCandidate(1), bestCandidate(2), bestCandidate(3), ...
        vIRtInputCurrents(bestCandidate(1)), ...
        vIRtStdTimes(bestCandidate(2)), ...
        fmnInputCurrents(bestCandidate(3)));
end

%% Output results: Heatmaps

% Define axes limits for the heatmaps based on parameter ranges
xCorner = [vIRtStdTimes(1), vIRtStdTimes(end)];
yCorner = [vIRtInputCurrents(1), vIRtInputCurrents(end)];

% Extract tau time parameter for labeling
tauTime = output.intrinsicDefault.vIRtInput(1).vIRtStdTime(1).FMNInput(1).params.ExtCurrent.Rr.tauTime;

% Generate a figure for each FMN input current level
for k = 1:nFmnInputCurrents
    figure;

    % Subplot 1: Frequency Heatmap
    subplot(3, 1, 1)
    % Create mask for valid data points
    mask = ~isnan(squeeze(intrinsicFreqsInLimits(:, :, k)));
    % Plot heatmap
    imagesc(xCorner, yCorner, squeeze(intrinsicFreqAll(:, :, k)), rangeFreq); 
    colormap turbo; colorbar;
    % Overlay outlines for valid regions
    jm_annotate_imageplot_pixel_outlines(vIRtStdTimes, vIRtInputCurrents, mask);
    % Overlay text values
    jm_annotate_imageplot_pixel_values_text(vIRtStdTimes, vIRtInputCurrents, squeeze(intrinsicFreqAll(:, :, k)));
    title('Frequency (Hz)')
    
    % Subplot 2: Amplitude Heatmap
    subplot(3, 1, 2)
    % Create mask for valid data points
    mask = ~isnan(squeeze(intrinsicAmpsInLimits(:, :, k)));
    % Plot heatmap
    imagesc(xCorner, yCorner, squeeze(intrinsicAmpAll(:, :, k)), rangeAmp); 
    colormap turbo; colorbar;
    % Overlay outlines for valid regions
    jm_annotate_imageplot_pixel_outlines(vIRtStdTimes, vIRtInputCurrents, mask);
    % Overlay text values
    jm_annotate_imageplot_pixel_values_text(vIRtStdTimes, vIRtInputCurrents, squeeze(intrinsicAmpAll(:, :, k)));
    ylabel(['vIRt input current mean (pA), ', 'FMN input = ', num2str(fmnInputCurrents(k)), ' pA']);
    title('Amplitude (a.u.)')
    
    % Subplot 3: Set Point Heatmap
    subplot(3, 1, 3)
    % Create mask for valid data points
    mask = ~isnan(squeeze(intrinsicSetPtsInLimits(:, :, k)));
    % Plot heatmap
    imagesc(xCorner, yCorner, squeeze(intrinsicSetPtAll(:, :, k)), rangeSetPt); 
    colormap turbo; colorbar;
    % Overlay outlines for valid regions
    jm_annotate_imageplot_pixel_outlines(vIRtStdTimes, vIRtInputCurrents, mask);
    % Overlay text values
    jm_annotate_imageplot_pixel_values_text(vIRtStdTimes, vIRtInputCurrents, squeeze(intrinsicSetPtAll(:, :, k)));
    xlabel(['vIRt input current noise std (pA), tau = ', num2str(tauTime), ' ms']);
    title('Set point (a.u.)')

    % Save figure
    saveas(gcf, fullfile(figureDir, ['fig_virt_sim_ExtCurrent_analysis_heatmap_FMNInput_', num2str(k), '.png']));
    saveas(gcf, fullfile(figureDir, ['fig_virt_sim_ExtCurrent_analysis_heatmap_FMNInput_', num2str(k), '.fig']));
    saveas(gcf, fullfile(figureDir, ['fig_virt_sim_ExtCurrent_analysis_heatmap_FMNInput_', num2str(k), '.eps']), 'epsc');
end

%% Output results: Example Spectra

% Define the sets of indices to iterate over
spectraSets = {indicesToPlot1, indicesToPlot2, indicesToPlot3};
setNames = {'Set1', 'Set2', 'Set3'};

% Loop through each set of indices
for setIdx = 1:length(spectraSets)
    indicesToPlot = spectraSets{setIdx};
    
    % Skip if empty
    if isempty(indicesToPlot)
        fprintf('Skipping spectra plot for %s (empty).\n', setNames{setIdx});
        continue; 
    end
    
    % Create a new figure to overlay spectra plots for this set
    figure; hold on;
    % Add header to title for legend notation key
    title({['Example Spectra - ' setNames{setIdx}]; 'Legend notation: \mu (pA), \sigma (pA), F (pA), f_{intrinsic} (Hz), FWHM (Hz)'});

    % Initialize cell array for legend labels
    legendLabels = cell(size(indicesToPlot, 1), 1);

    % Initialize array to store FWHM values for statistical calculation
    fwhmValues = zeros(size(indicesToPlot, 1), 1);
    % Initialize array for plot handles ensuring only spectra lines are in legend
    mainPlotHandles = gobjects(size(indicesToPlot, 1), 1);

    fprintf('\n--- Example Spectra Details (%s) ---\n', setNames{setIdx});

    % Loop through the selected indices to plot spectra
    for idx = 1:size(indicesToPlot, 1)
        i = indicesToPlot(idx, 1);
        j = indicesToPlot(idx, 2);
        k = indicesToPlot(idx, 3);
        
        % Retrieve parameter values
        valMu = vIRtInputCurrents(i);
        valSigma = vIRtStdTimes(j);
        valF = fmnInputCurrents(k);
        valFreq = intrinsicFreqAll(i, j, k);
        
        % Retrieve Pre-Computed FWHM and edge frequencies
        % (Computed once in parfor loop)
        currentFWHM = intrinsicFWHMAll(i, j, k);
        fLeft = intrinsicFLeftAll(i, j, k);
        fRight = intrinsicFRightAll(i, j, k);
        
        % Store FWHM in array for later statistical calculation
        fwhmValues(idx) = currentFWHM;
        
        % Extract the effector vector for this specific simulation (needed for plotting curve)
        effectorVec = output.intrinsicDefault.vIRtInput(i).vIRtStdTime(j).FMNInput(k).effectorVec;
        dt = output.intrinsicDefault.vIRtInput(i).vIRtStdTime(j).FMNInput(k).params.dt / 1000;
        
        % Update Sampling Frequency (Fs) for this specific trace
        params.Fs = (1 / dt) / downsampleFactor;
        
        % Process the data: Take steady state and downsample
        effectorSteadyState = effectorVec(ceil(end/2):end);
        effectorDownsampled = effectorSteadyState(1:downsampleFactor:end);
        
        % Compute the spectrum for PLOTTING only
        [S, f] = mtspectrumc(effectorDownsampled - mean(effectorDownsampled), params);
        
        % Plot normalized spectrum and store handle
        p = plot(f, S / max(S), 'LineWidth', 1.5);
        mainPlotHandles(idx) = p;
        
        % Plot intrinsic frequency as a dashed vertical line
        plot_vertical_line(valFreq, 'LineStyle', '--', 'Color', ...
                            get(p, 'Color'), 'LineWidth', 1);
        
        % Print details to standard output with units
        fprintf(['Index %d: (%d,%d,%d)|(%.2f,%.2f,%.2f) -> ', ...
                    'Intrinsic Freq (f) = %.2f Hz, FWHM = %.2f Hz\n'], ...
            idx, i, j, k, valMu, valSigma, valF, valFreq, currentFWHM);

        % Plot FWHM as double arrows using pre-computed fLeft and fRight
        
        % Calculate stacked Y position (Centered Group, Top to Bottom)
        yOffset = 0.025;
        numIndices = size(indicesToPlot, 1);
        
        % Calculate the starting Y level (top of the stack)
        % The stack height is (numIndices - 1) * yOffset
        % Center is 0.5. So top is 0.5 + (height / 2)
        yStart = 0.5 + ((numIndices - 1) * yOffset) / 2;
        
        % Current level is yStart minus offset for current index (0-based)
        yLevel = yStart - (idx - 1) * yOffset;

        % Draw the line shaft
        line([fLeft, fRight], [yLevel, yLevel], 'Color', get(p, 'Color'), ...
             'LineStyle', '-', 'LineWidth', 1, 'HandleVisibility', 'off');
         
        % Draw the arrow heads (using markers to simulate double arrow)
        plot(fLeft, yLevel, '<', 'Color', get(p, 'Color'), 'MarkerFaceColor', ...
                get(p, 'Color'), 'HandleVisibility', 'off');
        plot(fRight, yLevel, '>', 'Color', get(p, 'Color'), 'MarkerFaceColor', ...
                get(p, 'Color'), 'HandleVisibility', 'off');

        % Store concise numbers in legend label
        legendLabels{idx} = sprintf('%g, %g, %g, %.2f, %.2f', ...
            valMu, valSigma, valF, valFreq, currentFWHM);
    end

    % Calculate and display summary statistics for FWHM
    meanFWHM = mean(fwhmValues);
    stdFWHM = std(fwhmValues);
    stderrFWHM = std(fwhmValues)/sqrt(numel(fwhmValues));
    err95FWHM = compute_stats(fwhmValues, 'err95');

    fprintf('\n--- FWHM Summary Statistics (%s) ---\n', setNames{setIdx});
    fprintf('Mean FWHM: %.2f Hz\n', meanFWHM);
    fprintf('Standard Deviation FWHM: %.2f Hz\n', stdFWHM);
    fprintf('Standard Error of the Mean FWHM: %.2f Hz\n', stderrFWHM);
    fprintf('95%% Confidence Error of the Mean FWHM: %.2f Hz\n', err95FWHM);

    % Add labels and legend to the spectra plot
    xlabel('Frequency (Hz)');
    ylabel('Power relative to peak');
    legend(mainPlotHandles, legendLabels);

    % Save figure with set-specific suffix
    saveas(gcf, fullfile(figureDir, ['fig_virt_sim_ExtCurrent_analysis_example_spectra_' setNames{setIdx} '.png']));
    saveas(gcf, fullfile(figureDir, ['fig_virt_sim_ExtCurrent_analysis_example_spectra_' setNames{setIdx} '.fig']));
    saveas(gcf, fullfile(figureDir, ['fig_virt_sim_ExtCurrent_analysis_example_spectra_' setNames{setIdx} '.eps']), 'epsc');
end

%% Output results: Example Traces

% Create a new figure for trace plots
figure;

% Example 1: Set specific indices
i = indicesToPlot3(orderExample1, 1);
j = indicesToPlot3(orderExample1, 2);
k = indicesToPlot3(orderExample1, 3);

% Retrieve parameter values for label
valMu = vIRtInputCurrents(i);
valSigma = vIRtStdTimes(j);
valF = fmnInputCurrents(k);

% Extract and process the vector
effectorVec = output.intrinsicDefault.vIRtInput(i).vIRtStdTime(j).FMNInput(k).effectorVec;
effectorSteadyState = effectorVec(ceil(end/2):end);
effectorDownsampled = effectorSteadyState(1:downsampleFactor:end);
dt = output.intrinsicDefault.vIRtInput(i).vIRtStdTime(j).FMNInput(k).params.dt / 1000;
fs = (1 / dt) / downsampleFactor;
t = (1:length(effectorDownsampled)) / fs;

% Define time window mask for plotting
tPlotMask = t >= timeWinExample(1) & t <= timeWinExample(2);

% Plot the first example trace
subplot(2, 1, 1)
plot(t(tPlotMask), effectorDownsampled(tPlotMask));
ylim(yLimitsExample);
ylabel('Position (a.u.)')
title('Sample effector outputs')

% Add text label
textLabel = sprintf('\\mu = %g, \\sigma = %g, F = %g (pA)', valMu, valSigma, valF);
text(0.02, 0.9, textLabel, 'Units', 'normalized', 'FontSize', 9, 'BackgroundColor', 'w', 'EdgeColor', 'k');

% Example 2: Set specific indices
i = indicesToPlot3(orderExample2, 1);
j = indicesToPlot3(orderExample2, 2);
k = indicesToPlot3(orderExample2, 3);

% Retrieve parameter values for label
valMu = vIRtInputCurrents(i);
valSigma = vIRtStdTimes(j);
valF = fmnInputCurrents(k);

% Extract and process the vector
effectorVec = output.intrinsicDefault.vIRtInput(i).vIRtStdTime(j).FMNInput(k).effectorVec;
effectorSteadyState = effectorVec(ceil(end/2):end);
effectorDownsampled = effectorSteadyState(1:downsampleFactor:end);
dt = output.intrinsicDefault.vIRtInput(i).vIRtStdTime(j).FMNInput(k).params.dt / 1000;
fs = (1 / dt) / downsampleFactor;
t = (1:length(effectorDownsampled)) / fs;

% Plot the second example trace
subplot(2, 1, 2)
plot(t(tPlotMask), effectorDownsampled(tPlotMask));
ylim(yLimitsExample);
xlabel('Time (s)')
ylabel('Position (a.u.)')

% Add text label
textLabel = sprintf('\\mu = %g, \\sigma = %g, F = %g (pA)', valMu, valSigma, valF);
text(0.02, 0.9, textLabel, 'Units', 'normalized', 'FontSize', 9, 'BackgroundColor', 'w', 'EdgeColor', 'k');

% Save figure
saveas(gcf, fullfile(figureDir, 'fig_virt_sim_ExtCurrent_analysis_example_trace.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_sim_ExtCurrent_analysis_example_trace.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_sim_ExtCurrent_analysis_example_trace.eps'), 'epsc');

fprintf('Analysis complete. Log saved to %s\n', logFile);
diary off;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [fwhm, fLeft, fRight] = calc_fwhm_from_spectrum(S, f)
% Calculates Full Width at Half Maximum (FWHM) from a power spectrum

[maxVal, maxIdx] = max(S);
halfMax = maxVal / 2;

% Find index to the left of peak where value drops below halfMax
leftIdx = find(S(1:maxIdx) < halfMax, 1, 'last');
if isempty(leftIdx), leftIdx = 1; end

% Find index to the right of peak where value drops below halfMax
rightIdx = find(S(maxIdx:end) < halfMax, 1, 'first');
if isempty(rightIdx)
    rightIdx = length(S);
else
    rightIdx = rightIdx + maxIdx - 1;
end

% Linear interpolation to find precise frequency for left side
if leftIdx < maxIdx && leftIdx < length(S)
    y1 = S(leftIdx); y2 = S(leftIdx+1);
    f1 = f(leftIdx); f2 = f(leftIdx+1);
    fLeft = f1 + (halfMax - y1) * (f2 - f1) / (y2 - y1);
else
    fLeft = f(leftIdx);
end

% Linear interpolation to find precise frequency for right side
if rightIdx > 1 && rightIdx <= length(S)
    y1 = S(rightIdx-1); y2 = S(rightIdx);
    f1 = f(rightIdx-1); f2 = f(rightIdx);
    fRight = f1 + (halfMax - y1) * (f2 - f1) / (y2 - y1);
else
    fRight = f(rightIdx);
end

% Calculate FWHM
fwhm = fRight - fLeft;

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{
OLD CODE:

%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%