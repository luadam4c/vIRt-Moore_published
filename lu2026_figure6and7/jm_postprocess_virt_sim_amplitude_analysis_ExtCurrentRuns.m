% jm_postprocess_virt_sim_amplitude_analysis_ExtCurrentRuns.m
%% Calculate vIRt Network Output Amplitude vs. Drive Frequency (External Current Runs)
% Usage: Run directly as a script.
% Explanation:
%       Calculates the vIRt network output amplitude as a function of drive 
%       frequency for selected simulations with different values of vIRt 
%       input current (mean, stdTime, and Facial motor neuron mean input).
%       Results in intrinsic frequencies spanning 5-10 Hz.
%       Period variability = 0%.
%
% Inputs:
%       All data files in outDir matching pattern: 'simData_vary_freq_ExtCurrentSims_inputSet*.mat'
%           that is generated by jm_automate_rerun_virt_sim_from_params_intrinsic_vs_driven_freq.m
%
% Outputs:
%       Generates figures for individual runs, heatmaps of amplification,
%       and frequency difference analysis.
%       This is Figure 7b - 7e in Lu et al 2026
%
% Requires:
%       mtspectrumc.m and dependent files from the Chronux toolbox
%       \Shared\Code\Adams_Functions\archive_dependent_scripts.m
%       \Shared\Code\vIRt-Moore\jm_virt_sim_calc_dominant_freq_spectral.m
%
% File History:
% 2025-12-12 Created by Jeff Moore
% 2026-01-09 Updated for new data set
% 2026-01-13 Reorganized and reannotated by Gemini
% 2026-01-14 Standardized file paths and parameters by Gemini
% 2026-01-15 Added backward compatibility for variable names and fields by Gemini
% 2026-01-16 Now archives dependent scripts
% 2026-01-16 Now detects input files using pattern matching (Updated by Gemini)
% 2026-01-25 Added text labels to individual file plots by Gemini

%% Hard-coded parameters
% Define output directory
outDir = pwd;

% Define file pattern for simulation data sets (assumed to be in outDir)
simDataFilePattern = 'simData_vary_freq_ExtCurrentSims_inputSet*.mat';

% Define Chronux dependency name and relative path
nameChronuxFile = 'mtspectrumc.m';
scriptDir = fileparts(mfilename('fullpath'));
pathChronux = fullfile(scriptDir, 'chronux_2_12_annotated');

% Define output directory for figures
figureDir = fullfile(outDir, 'Figures');

% Define Chronux spectral analysis parameters
%   Note: traces are noisy with noisy inputs, need NW = 7.5 or 15
%           7.5 = 0.5 Hz resolution for 15 sec
%           15 = 1 Hz resolution for 15 sec
NW = 15;                        % Time half-bandwidth product
params.tapers = [NW, floor((2 * NW) - 1)];
params.pad    = -1;             % -1 default (no padding)
params.fpass  = [0, 15];        % Frequency pass band
params.err    = [2, 0.05];      % Error calculation [Jackknife, p-value]
params.trialave = 1;            % Average over trials

% General analysis parameters
downsampleFactor = 10;          % Downsampling factor for spectral calculation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Preparation

% Check for Chronux and add to path
if ~exist(nameChronuxFile, 'file')
    if exist(pathChronux, 'dir')
        addpath(pathChronux);
        fprintf('%s and dependent files found and added to path.\n', nameChronuxFile);
    else
        warning('%s and dependent files not found at: %s. Spectral analysis may fail.', nameChronuxFile, pathChronux);
    end
end

% Create figure directory if it doesn't exist
if ~exist(figureDir, 'dir')
    mkdir(figureDir);
    fprintf('Created figure directory: %s\n', figureDir);
end

% Start logging to file
logFile = fullfile(figureDir, 'analysis_log_amplitude_ExtCurrentRuns.txt');
if exist(logFile, 'file')
    delete(logFile);
end
diary(logFile);
fprintf('Log started at %s\n', char(datetime('now')));
fprintf('------------------------------------------------------------\n');

% Copy this script and its dependencies to the output directory
archive_dependent_scripts(mfilename, 'OutFolder', outDir);

% Find all data files matching desired pattern in outDir
fileList = dir(fullfile(outDir, simDataFilePattern));
if isempty(fileList)
    error('No files found matching pattern: %s', simDataFilePattern);
end

% Extract file names into a cell array
simDataFiles = {fileList.name}';

% Perform Natural Sorting (e.g., ensuring inputSet2 comes before inputSet10)
% Extract the number from 'inputSetX.mat'
tokens = regexp(simDataFiles, 'inputSet(\d+).mat', 'tokens');
fileIndices = zeros(length(simDataFiles), 1);
for i = 1:length(simDataFiles)
    if ~isempty(tokens{i})
        fileIndices(i) = str2double(tokens{i}{1}{1});
    else
        fileIndices(i) = inf; % Push non-matching patterns to the end
    end
end
[~, sortOrder] = sort(fileIndices);
simDataFiles = simDataFiles(sortOrder);

fprintf('Found %d simulation files matching pattern "%s".\n', length(simDataFiles), simDataFilePattern);

% Initialize containers
nFiles = size(simDataFiles, 1);
intrinsicFreqsAll = [];
intrinsicAmpsAll = [];
drivenAmpsAll = [];

%% Do the job
% Run over all simulations
fprintf('\n--- Processing Simulation Files ---\n');
fprintf('%-10s %-20s %-20s\n', 'FileID', 'Intrinsic Freq (Hz)', 'Intrinsic Amp (a.u.)');

for iFile = 1:nFiles
    
    disp(['Loading file ', num2str(iFile), ': ', simDataFiles{iFile}]);
    
    % Construct full path and load data
    simDataFile = fullfile(outDir, simDataFiles{iFile});
    load(simDataFile);
    % Note: Loading simDataFile introduces 'output', 
    %               'testFrequencies' or 'test_frequencies',
    %               'testPerVar' or 'test_perVar',
    %               'vIRtInputCurrents' or 'vIRt_input_currents',
    %               'vIRtStdTimes' or 'vIRt_stdTimes', 
    %               'fmnInputCurrents' or 'FMN_input_currents',
    %               'virtInputInd' or 'vIRtInputInd', 
    %               'virtStdTimeInd' or 'vIRtStdTimeInd', 
    %               'fmnInputInd' or 'FMNInputInd',
    %       into workspace
    disp('Data file loaded!');

    % Backwards Compatibility: Variable Names
    if exist('test_frequencies', 'var') && ~exist('testFrequencies', 'var')
        testFrequencies = test_frequencies;
    end
    if exist('test_perVar', 'var') && ~exist('testPerVar', 'var')
        testPerVar = test_perVar;
    end
    if exist('vIRt_input_currents', 'var') && ~exist('vIRtInputCurrents', 'var')
        vIRtInputCurrents = vIRt_input_currents;
    end
    if exist('vIRt_stdTimes', 'var') && ~exist('vIRtStdTimes', 'var')
        vIRtStdTimes = vIRt_stdTimes;
    end
    if exist('FMN_input_currents', 'var') && ~exist('fmnInputCurrents', 'var')
        fmnInputCurrents = FMN_input_currents;
    end
    if exist('vIRtInputInd', 'var') && ~exist('virtInputInd', 'var')
        virtInputInd = vIRtInputInd;
    end
    if exist('vIRtStdTimeInd', 'var') && ~exist('virtStdTimeInd', 'var')
        virtStdTimeInd = vIRtStdTimeInd;
    end
    if exist('FMNInputInd', 'var') && ~exist('fmnInputInd', 'var')
        fmnInputInd = FMNInputInd;
    end

    % 1. Calculate Intrinsic Frequency and Amplitude
    effectorVec = output.intrinsicDefault.data.effectorVec;
    effectorSteadyState = effectorVec(ceil(end/2):end);
    dtSeconds = output.intrinsicDefault.params.dt / 1000; 
    
    [intrinsicFreq, intrinsicAmp, intrinsicSetPt] = ...
        jm_virt_sim_calc_dominant_freq_spectral(effectorSteadyState, dtSeconds, downsampleFactor, params);
    
    % Backwards Compatibility: Field Names
    if isfield(output.intrinsicDefault.analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
        intrinsicAmpProbe = output.intrinsicDefault.analysis.whisk.meanFirstPeakAmplitudeSecondHalf; 
    elseif isfield(output.intrinsicDefault.analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
        intrinsicAmpProbe = output.intrinsicDefault.analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
    else
        error('Amplitude field not found in intrinsicDefault analysis struct.');
    end

    % Print intrinsic values for this file
    fprintf('%-10d %-20.4f %-20.4f\n', iFile, intrinsicFreq, intrinsicAmpProbe);

    % 2. Extract Driven Amplitudes
    nFreqs = length(testFrequencies);
    nPerVar = length(testPerVar);
    ampMatrix = zeros(nFreqs, nPerVar);
    
    for iFreq = 1:nFreqs
        for iPerVar = 1:nPerVar
            % Backwards Compatibility: Field Names
            if isfield(output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
                ampMatrix(iFreq, iPerVar) = output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk.meanFirstPeakAmplitudeSecondHalf;
            elseif isfield(output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
                ampMatrix(iFreq, iPerVar) = output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
            else
                error('Amplitude field not found in drivenDefault analysis struct.');
            end
        end
    end
    disp('Done!');

    % 3. Individual File Plot
    figure;
    plot(testFrequencies, ampMatrix);
    legend(num2str(testPerVar'));
    line(xlim, [1 1] * intrinsicAmpProbe);
    line([1 1] * intrinsicFreq, ylim);
    ylim([0 200]);
    xlabel('Drive frequency (Hz)');
    ylabel('First whisk amplitude');
    
    % Retrieve parameter values for label if variables exist
    if exist('vIRtInputCurrents', 'var') && exist('virtInputInd', 'var')
        valMu = vIRtInputCurrents(virtInputInd);
        valSigma = vIRtStdTimes(virtStdTimeInd);
        valF = fmnInputCurrents(fmnInputInd);
        
        % Add text label
        textLabel = sprintf('\\mu = %g, \\sigma = %g, F = %g (pA)', valMu, valSigma, valF);
        text(0.02, 0.9, textLabel, 'Units', 'normalized', 'FontSize', 9, ...
             'BackgroundColor', 'w', 'EdgeColor', 'k');
    end
    
    % Save individual figures
    saveas(gcf, fullfile(figureDir, ['fig_virt_amp_vs_drive_ExtCurrent_file_', num2str(iFile), '.png']));
    saveas(gcf, fullfile(figureDir, ['fig_virt_amp_vs_drive_ExtCurrent_file_', num2str(iFile), '.fig']));
    saveas(gcf, fullfile(figureDir, ['fig_virt_amp_vs_drive_ExtCurrent_file_', num2str(iFile), '.eps']), 'epsc');

    % 4. Collect outputs into matrix
    intrinsicFreqsAll = [intrinsicFreqsAll, intrinsicFreq];
    intrinsicAmpsAll = [intrinsicAmpsAll, intrinsicAmpProbe];
    drivenAmpsAll = [drivenAmpsAll, ampMatrix];
end

%% Plotting Summary Statistics
% Plot heatmap of amplifications
intrinsicAmpsRep = repmat(intrinsicAmpsAll, nFreqs, 1);
relAmp = drivenAmpsAll ./ intrinsicAmpsRep;

% Print Summary Matrices
fprintf('\n--- Summary Statistics ---\n');
fprintf('Intrinsic Frequencies All Files (Hz):\n');
disp(intrinsicFreqsAll);

fprintf('Intrinsic Amplitudes All Files (a.u.):\n');
disp(intrinsicAmpsAll);

fprintf('Driven Amplitudes Matrix (Rows=Freqs, Cols=Files):\n');
disp(drivenAmpsAll);

fprintf('Relative Amplification Matrix (Rows=Freqs, Cols=Files):\n');
disp(relAmp);

figure;
heatmap(intrinsicFreqsAll, fliplr(testFrequencies), flipud(relAmp)); 
colormap turbo;
xlabel('Intrinsic Frequency (Hz)');
ylabel('Drive Frequency (Hz)');
title('Amplification factor (Driven Amp/Intrinsic Amp)');

% Save heatmap
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_heatmap_amplification.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_heatmap_amplification.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_heatmap_amplification.eps'), 'epsc');

% Plot frequency of maximal driven response vs intrinsic frequency
[maxFreq, maxFreqIndices] = max(drivenAmpsAll);
figure;
plot(intrinsicFreqsAll, testFrequencies(maxFreqIndices), '.');
line([5 10], [5 10]);
xlabel('Intrinsic Frequency (Hz)');
ylabel('Frequency of maximum amplification (Hz)');

% Save max response plot
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_max_response_freq.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_max_response_freq.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_max_response_freq.eps'), 'epsc');

% Plot amplitude as a function of frequency difference
figure; hold on;
for iFile = 1:nFiles
    freqDiff = testFrequencies - intrinsicFreqsAll(iFile);
    plot(freqDiff, relAmp(:, iFile));
end
xlabel('dF frequency (driven - intrinsic)');
ylabel('Relative amplitude');
legend(num2str(intrinsicFreqsAll'));

% Save frequency difference plot
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_freq_difference.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_freq_difference.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_freq_difference.eps'), 'epsc');

% Optional Normalized Plot (Commented out)
% relAmpNorm = relAmp / max(max(relAmp));
% figure;
% hold on;
% for i=1:37
%     for j=1:7
%         plot(test_frequencies(i), intrinsicFreqsAll(j), 'square', ...
%              'MarkerFaceColor', relAmpNorm(i,j)*[1 0 0], ...
%              'MarkerEdgeColor', relAmpNorm(i,j)*[1 0 0], ...
%              'MarkerSize', 48);
%     end
% end
% line([5 9], [5 9], 'Color', 'k');

fprintf('Analysis complete. Log saved to %s\n', logFile);
diary off;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{
OLD CODE:

%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%