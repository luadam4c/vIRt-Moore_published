% jm_postprocess_virt_sim_amplitude_analysis.m
%% Calculate Default vIRt Network Output Amplitude vs. Drive Frequency
% Usage: Run directly as a script.
% Explanation:
%       Calculates the default vIRt network output amplitude as a function of 
%       drive frequency. It compares the driven response to the intrinsic 
%       frequency and amplitude of the system.
%
%       Analyzes different values of period variability (0 = 0%, 1 = 100%).
%       T = 1/drive_frequency.
%
% Inputs:
%       Most recent simulation data file matching pattern: 'simData_vary_freq_perVar_*.mat'
%           that is generated by jm_automate_virt_sim_vary_freq_perVar.m
%
% Outputs:
%       Generates a figure plotting First Whisk Amplitude vs. Drive Frequency.
%       This is Figure 4m in Lu et al 2026
%
% Requires:
%       mtspectrumc.m and dependent files from the Chronux toolbox
%       \Shared\Code\Adams_Functions\archive_dependent_scripts.m
%       \Shared\Code\vIRt-Moore\jm_virt_sim_calc_dominant_freq_spectral.m
%
% File History:
% 2025-12-12 Created by Jeff Moore
% 2026-01-09 Updated for new data set
% 2026-01-13 Reorganized and reannotated by Gemini
% 2026-01-15 Added backward compatibility for variable names and fields by Gemini
% 2026-01-16 Now archives dependent scripts
% 2026-01-16 Now detects input files using pattern matching

%% Hard-coded parameters
% Define file paths for data and dependencies
outDir = pwd;
simDataFilePattern = 'simData_vary_freq_perVar_*.mat';

nameChronuxFile = 'mtspectrumc.m';
scriptDir = fileparts(mfilename('fullpath'));
pathChronux = fullfile(scriptDir, 'chronux_2_12_annotated');

% Define output directory for figures
figureDir = fullfile(outDir, 'Figures');

% Define Chronux spectral analysis parameters
%   Note: traces are noisy with noisy inputs, need NW = 7.5 or 15
%           7.5 = 0.5 Hz resolution for 15 sec
%           15 = 1 Hz resolution for 15 sec
NW = 15;                        % Time half-bandwidth product
params.tapers = [NW, floor((2 * NW) - 1)];
params.pad    = -1;             % -1 default (no padding)
params.fpass  = [0, 15];        % Frequency pass band
params.err    = [2, 0.05];      % Error calculation [Jackknife, p-value]
params.trialave = 1;            % Average over trials

% General parameters
downsampleFactor = 10;          % Downsampling factor for spectral calculation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Preparation
% If not exist, add path for the required function from the Chronux package
if ~exist(nameChronuxFile, 'file')
    if exist(pathChronux, 'dir')
        addpath(pathChronux);
        fprintf('%s and dependent files found and added to path.\n', nameChronuxFile);
    else
        warning('%s and dependent files not found at: %s. Spectral analysis may fail.', nameChronuxFile, pathChronux);
    end
end

% Create figure directory if it doesn't exist
if ~exist(figureDir, 'dir')
    mkdir(figureDir);
    fprintf('Created figure directory: %s\n', figureDir);
end

% Copy this script and its dependencies to the output directory
archive_dependent_scripts(mfilename, 'OutFolder', outDir);

% Find and load simulation data
fileList = dir(fullfile(outDir, simDataFilePattern));
if isempty(fileList)
    error('No files found matching pattern: %s', simDataFilePattern);
end

% Sort by date (descending) to get the most recent file
[~, idx] = sort([fileList.datenum], 'descend');
simDataFile = fullfile(fileList(idx(1)).folder, fileList(idx(1)).name);
fprintf('Auto-detected most recent data file: %s\n', simDataFile);

%% Load Data
disp(['Loading file... ']);
load(simDataFile);
% Note: Loading simDataFile introduces 'output', 
%               'testFrequencies' or 'test_frequencies',
%               'testPerVar' or 'test_perVar' into workspace
disp('Data file loaded!');

% Backwards Compatibility: Variable Names
if exist('test_frequencies', 'var') && ~exist('testFrequencies', 'var')
    testFrequencies = test_frequencies;
end
if exist('test_perVar', 'var') && ~exist('testPerVar', 'var')
    testPerVar = test_perVar;
end

%% Do the job
% 1. Calculate Intrinsic Frequency and Amplitude
% Extract steady state effector vector
effectorVec = output.intrinsicDefault.data.effectorVec;
effectorSteadyState = effectorVec(ceil(end/2):end);
dtSeconds = output.intrinsicDefault.params.dt / 1000; 

% Calculate spectral properties
[intrinsicFreq, intrinsicAmp, intrinsicSetPt] = ...
    jm_virt_sim_calc_dominant_freq_spectral(effectorSteadyState, dtSeconds, downsampleFactor, params);

% Get amplitude from the probe analysis for consistency
% Backwards Compatibility: Field Names
if isfield(output.intrinsicDefault.analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
    intrinsicAmpProbe = output.intrinsicDefault.analysis.whisk.meanFirstPeakAmplitudeSecondHalf; 
elseif isfield(output.intrinsicDefault.analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
    intrinsicAmpProbe = output.intrinsicDefault.analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
else
    error('Amplitude field not found in intrinsicDefault analysis struct.');
end

% 2. Extract Driven Amplitudes
nFreqs = length(testFrequencies);
nPerVar = length(testPerVar);
ampMatrix = zeros(nFreqs, nPerVar);

for iFreq = 1:nFreqs
    for iPerVar = 1:nPerVar
        % Backwards Compatibility: Field Names
        if isfield(output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
            ampMatrix(iFreq, iPerVar) = output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk.meanFirstPeakAmplitudeSecondHalf;
        elseif isfield(output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
            ampMatrix(iFreq, iPerVar) = output.drivenDefault.freq(iFreq).var(iPerVar).analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
        else
            error('Amplitude field not found in drivenDefault analysis struct.');
        end
    end
end
disp('Done!');

%% Plotting
figure;
plot(testFrequencies, ampMatrix);
legend(num2str(testPerVar'));

% Add reference lines for intrinsic properties
line(xlim, [1 1] * intrinsicAmpProbe);
line([1 1] * intrinsicFreq, ylim);

xlabel('Drive frequency (Hz)');
ylabel('First whisk amplitude');

% Save figures
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_vs_drive_frequency_byPerVar.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_vs_drive_frequency_byPerVar.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_vs_drive_frequency_byPerVar.eps'), 'epsc');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{
OLD CODE:

%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%