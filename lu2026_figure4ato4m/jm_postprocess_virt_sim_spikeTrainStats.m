% jm_postprocess_virt_sim_spikeTrainStats.m
%% Analyze Spike Train Statistics for Automated Simulation Results
% Usage: Run directly as a script.
% Explanation:
%       Analyzes and plots spike train statistics (coherence, firing rates, 
%       phase relationships) for specific vIRt simulation conditions:
%       Intrinsic, Basal, Sniffing, and Detuned.
%
%       Plots raw traces and summary polar plots for each condition.
%       Calls jm_virt_sim_plot_virt_spike_coherence for detailed coherence plots.
%       Prints statistics to stdout and saves them to a log file.
%
% Inputs:
%       Most recent simulation data file matching pattern: 'simData_vary_freq_perVar_*.mat'
%           that is generated by jm_automate_virt_sim_vary_freq_perVar.m
%
% Outputs:
%       Generates 4 figures (one for each condition) containing traces and
%       stats.
%       This is Figure 4a - 4l in Lu et al 2026
%
%       Generates a text log file 'virt_spike_stats_log.txt' with summary stats.
%
% Requires:
%       mtspectrumc.m and dependent files from the Chronux toolbox
%       coherencycpt.m and dependent files from the Chronux toolbox
%       \Shared\Code\Adams_Functions\archive_dependent_scripts.m
%       \Shared\Code\Adams_Functions\plot_vertical_shade.m
%       \Shared\Code\vIRt-Moore\jm_virt_sim_calc_virt_spike_coherence.m
%       \Shared\Code\vIRt-Moore\jm_virt_sim_plot_virt_spike_coherence.m
%
% File History:
% 2025-12-12 Created by Jeff Moore
% 2026-01-09 Updated for new data set
% 2026-01-13 Reorganized and reannotated by Gemini
% 2026-01-14 Standardized file paths and parameters by Gemini
% 2026-01-15 Added backward compatibility for variable names by Gemini
% 2026-01-16 Now archives dependent scripts
% 2026-01-16 Now detects input files using pattern matching
% 2026-01-21 Added logging of statistics to file and stdout by Gemini

%% Hard-coded parameters
% Define output directory
outDir = pwd;

% Define file pattern for simulation data (assumed to be in outDir)
simDataFilePattern = 'simData_vary_freq_perVar_*.mat';

% Define Chronux dependency name and relative path
nameChronuxFile = 'mtspectrumc.m';
scriptDir = fileparts(mfilename('fullpath'));
pathChronux = fullfile(scriptDir, 'chronux_2_12_annotated');

% Define output directory for figures
figureDir = fullfile(outDir, 'Figures');

% Define log file path
logFileName = 'virt_spike_stats_log.txt';
logFilePath = fullfile(figureDir, logFileName);

% Pool indices in simulation data
rrPoolInd = 2;  % Index of vIRt-retraction pool in the spikeTimesCell array
rpPoolInd = 3;  % Index of vIRt-protraction pool in the spikeTimesCell array

% Indices of driven vIRt network to calculate
basalInd = 2;       % Index corresponding to 1.25 Hz in testFrequencies
sniffingInd = 21;   % Index corresponding to 6 Hz in testFrequencies
detuneInd = 37;     % Index corresponding to 10 Hz in testFrequencies
perVarInd = 1;      % Index corresponding to 0 % in testPerVar

% Define Chronux spectral analysis parameters
%   Note: traces are noisy with noisy inputs, need NW = 7.5 or 15
%           7.5 = 0.5 Hz resolution for 15 sec
%           15 = 1 Hz resolution for 15 sec
NW = 15;                        % Time half-bandwidth product
params.tapers = [NW, floor((2 * NW) - 1)];
params.pad    = -1;             % -1 default (no padding)
params.fpass  = [0, 15];        % Frequency pass band
params.err    = [2, 0.05];      % Error calculation [Jackknife, p-value]
params.trialave = 1;            % Average over trials

% Filter parameters for instantaneous phase calculation
downsampleFactor = 10;          % Downsampling factor for spectral calculation
fCutoffWhisk = [3, 25];         % bandpass filter cutoff for whisk trace (Moore et al 2013 used [3, 25] Hz)
filterOrderWhisk = 3;           % Butterworth filter order for whisk trace (Moore et al 2013 used 3)

% Plotting parameters
maxFrPlot = 40;                 % Max firing rate for tuning curve scaling

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Preparation

% Check for Chronux and add to path
if ~exist(nameChronuxFile, 'file')
    if exist(pathChronux, 'dir')
        addpath(pathChronux);
        fprintf('%s and dependent files found and added to path.\n', nameChronuxFile);
    else
        warning('%s and dependent files not found at: %s. Spectral analysis may fail.', nameChronuxFile, pathChronux);
    end
end

% Create figure directory if it doesn't exist
if ~exist(figureDir, 'dir')
    mkdir(figureDir);
    fprintf('Created figure directory: %s\n', figureDir);
end

% Copy this script and its dependencies to the output directory
archive_dependent_scripts(mfilename, 'OutFolder', outDir);

% Find and load simulation data
fileList = dir(fullfile(outDir, simDataFilePattern));
if isempty(fileList)
    error('No files found matching pattern: %s', simDataFilePattern);
end

% Sort by date (descending) to get the most recent file
[~, idx] = sort([fileList.datenum], 'descend');
simDataFile = fullfile(fileList(idx(1)).folder, fileList(idx(1)).name);
fprintf('Auto-detected most recent data file: %s\n', simDataFile);

%% Load Data
disp(['Loading data file...']);
load(simDataFile);
% Note: Loading simDataFile introduces 'output', 
%               'testFrequencies' or 'test_frequencies',
%               'testPerVar' or 'test_perVar' into workspace
disp('File loaded!');

% Backwards Compatibility: Variable Names
if exist('test_frequencies', 'var') && ~exist('testFrequencies', 'var')
    testFrequencies = test_frequencies;
end
if exist('test_perVar', 'var') && ~exist('testPerVar', 'var')
    testPerVar = test_perVar;
end

%% Do the job
% --- 1. Intrinsic vIRt network (not driven) ---
effInt = output.intrinsicDefault.data.effectorVec;
timeInt = output.intrinsicDefault.data.tVecSec;
% stimInt = output.intrinsicDefault.data.timesInputPbSec; 

spikesRrInt = output.intrinsicDefault.data.spikeTimesCell{rrPoolInd} / 1000;
spikesRpInt = output.intrinsicDefault.data.spikeTimesCell{rpPoolInd} / 1000;

% Calculate coherence
vsCohereCalcIntrinsic = jm_virt_sim_calc_virt_spike_coherence(...
    effInt, timeInt, spikesRrInt, spikesRpInt, params, downsampleFactor, fCutoffWhisk, filterOrderWhisk);

% --- 2. Basal Frequency Condition ---
effBasal = output.drivenDefault.freq(basalInd).var(perVarInd).data.effectorVec;
timeBasal = output.drivenDefault.freq(basalInd).var(perVarInd).data.tVecSec;
stimBasal = output.drivenDefault.freq(basalInd).var(perVarInd).data.timesInputPbSec;

spikesRrBasal = output.drivenDefault.freq(basalInd).var(perVarInd).data.spikeTimesCell{rrPoolInd} / 1000;
spikesRpBasal = output.drivenDefault.freq(basalInd).var(perVarInd).data.spikeTimesCell{rpPoolInd} / 1000;

vsCohereCalcBasal = jm_virt_sim_calc_virt_spike_coherence(...
    effBasal, timeBasal, spikesRrBasal, spikesRpBasal, params, downsampleFactor, fCutoffWhisk, filterOrderWhisk);

% --- 3. Sniffing Frequency Condition ---
effSniff = output.drivenDefault.freq(sniffingInd).var(perVarInd).data.effectorVec;
timeSniff = output.drivenDefault.freq(sniffingInd).var(perVarInd).data.tVecSec;
stimSniff = output.drivenDefault.freq(sniffingInd).var(perVarInd).data.timesInputPbSec;

spikesRrSniff = output.drivenDefault.freq(sniffingInd).var(perVarInd).data.spikeTimesCell{rrPoolInd} / 1000;
spikesRpSniff = output.drivenDefault.freq(sniffingInd).var(perVarInd).data.spikeTimesCell{rpPoolInd} / 1000;

vsCohereCalcSniffing = jm_virt_sim_calc_virt_spike_coherence(...
    effSniff, timeSniff, spikesRrSniff, spikesRpSniff, params, downsampleFactor, fCutoffWhisk, filterOrderWhisk);

% --- 4. Detuned Frequency Condition ---
effDetune = output.drivenDefault.freq(detuneInd).var(perVarInd).data.effectorVec;
timeDetune = output.drivenDefault.freq(detuneInd).var(perVarInd).data.tVecSec;
stimDetune = output.drivenDefault.freq(detuneInd).var(perVarInd).data.timesInputPbSec;

spikesRrDetune = output.drivenDefault.freq(detuneInd).var(perVarInd).data.spikeTimesCell{rrPoolInd} / 1000;
spikesRpDetune = output.drivenDefault.freq(detuneInd).var(perVarInd).data.spikeTimesCell{rpPoolInd} / 1000;

vsCohereCalcDetune = jm_virt_sim_calc_virt_spike_coherence(...
    effDetune, timeDetune, spikesRrDetune, spikesRpDetune, params, downsampleFactor, fCutoffWhisk, filterOrderWhisk);

%% Print and Log Statistics
fidLog = fopen(logFilePath, 'w');
if fidLog == -1
    warning('Could not open log file %s for writing. Printing to stdout only.', logFilePath);
end

fprintf('Printing stats to stdout and logging to: %s\n', logFilePath);

print_virt_stats(fidLog, 'Intrinsic (Not Driven)', vsCohereCalcIntrinsic);
print_virt_stats(fidLog, 'Basal Condition', vsCohereCalcBasal);
print_virt_stats(fidLog, 'Sniffing Condition', vsCohereCalcSniffing);
print_virt_stats(fidLog, 'Detuned Condition', vsCohereCalcDetune);

if fidLog ~= -1
    fclose(fidLog);
    fprintf('Statistics successfully saved to %s\n', logFilePath);
end

%% Plotting Stats
jm_virt_sim_plot_virt_spike_coherence(vsCohereCalcIntrinsic); 
% Save figure (assume this function creates a figure)
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_intrinsic.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_intrinsic.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_intrinsic.eps'), 'epsc');

jm_virt_sim_plot_virt_spike_coherence(vsCohereCalcBasal); 
% Save figure
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_basal.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_basal.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_basal.eps'), 'epsc');

jm_virt_sim_plot_virt_spike_coherence(vsCohereCalcSniffing); 
% Save figure
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_sniffing.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_sniffing.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_sniffing.eps'), 'epsc');

jm_virt_sim_plot_virt_spike_coherence(vsCohereCalcDetune); 
% Save figure
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_detune.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_detune.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_coherence_detune.eps'), 'epsc');

%% Plotting Raw Data and Annotations

% Figure 1: Intrinsic
figure(1); 
subplot(1, 9, [1 2]);
plot(timeInt, effInt);
xlim([10 12]); ylim([0 200]);
subplot(1, 9, [1 2]);
title(['vIRt Network Statistics: Intrinsic']);
subplot(1, 9, [6 7]); 
polarplot(0, maxFrPlot, 'b.');
% Save Figure 1
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_intrinsic_raw.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_intrinsic_raw.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_intrinsic_raw.eps'), 'epsc');

% Figure 2: Basal
figure(2); 
subplot(1, 9, [1 2]);
plot(timeBasal, effBasal);
plot_vertical_shade(stimBasal);
xlim([10 12]); ylim([0 200]);
subplot(1, 9, 3); 
line([1 1] * testFrequencies(basalInd), ylim, 'Color', 'r');
subplot(1, 9, [1 2]); 
title(['vIRt Network Statistics: Freq: ', num2str(testFrequencies(basalInd)), ...
       ' periodVariability: ', num2str(testPerVar(perVarInd))]);
subplot(1, 9, [6 7]); 
polarplot(0, maxFrPlot, 'b.');
% Save Figure 2
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_basal_raw.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_basal_raw.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_basal_raw.eps'), 'epsc');

% Figure 3: Sniffing
figure(3); 
subplot(1, 9, [1 2]);
plot(timeSniff, effSniff);
plot_vertical_shade(stimSniff);
xlim([10 12]); ylim([0 200]);
subplot(1, 9, 3); 
line([1 1] * testFrequencies(sniffingInd), ylim, 'Color', 'r');
subplot(1, 9, [1 2]); 
title(['vIRt Network Statistics: Freq: ', num2str(testFrequencies(sniffingInd)), ...
       ' periodVariability: ', num2str(testPerVar(perVarInd))]);
subplot(1, 9, [6 7]); 
polarplot(0, maxFrPlot, 'b.');
% Save Figure 3
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_sniffing_raw.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_sniffing_raw.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_sniffing_raw.eps'), 'epsc');

% Figure 4: Detuned
figure(4); 
subplot(1, 9, [1 2]);
plot(timeDetune, effDetune);
plot_vertical_shade(stimDetune);
xlim([10 12]); ylim([0 200]);
subplot(1, 9, 3); 
line([1 1] * testFrequencies(detuneInd), ylim, 'Color', 'r');
subplot(1, 9, [1 2]); 
title(['vIRt Network Statistics: Freq: ', num2str(testFrequencies(detuneInd)), ...
       ' periodVariability: ', num2str(testPerVar(perVarInd))]);
subplot(1, 9, [6 7]); 
polarplot(0, maxFrPlot, 'b.');
% Save Figure 4
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_detuned_raw.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_detuned_raw.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_spikeTrainStats_detuned_raw.eps'), 'epsc');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function print_virt_stats(fid, conditionName, stats)

% Calculates mean firing rate across the population
meanRateRr = mean(stats.Rr.Nspikes) / stats.timeSec;
meanRateRp = mean(stats.Rp.Nspikes) / stats.timeSec;

% Prepare message
msg = sprintf('\n========================================\n');
msg = [msg, sprintf('Condition: %s\n', conditionName)];
msg = [msg, sprintf('----------------------------------------\n')];
msg = [msg, sprintf('Dominant Frequency: %.2f Hz\n', stats.effector.dominantFreq)];

msg = [msg, sprintf('\n> vIRt-Retraction (Rr) Pool:\n')];
msg = [msg, sprintf('\tMean Firing Rate: %.2f Hz\n', meanRateRr)];
msg = [msg, sprintf('\tAggregate Coherence: %.4f\n', stats.Rr.CAgg)];
msg = [msg, sprintf('\tAggregate Phase:     %.4f rad\n', stats.Rr.phiAgg)];
msg = [msg, sprintf('\tCV2 (Local Var):     %.4f\n', stats.Rr.cv2)];

msg = [msg, sprintf('\n> vIRt-Protraction (Rp) Pool:\n')];
msg = [msg, sprintf('\tMean Firing Rate: %.2f Hz\n', meanRateRp)];
msg = [msg, sprintf('\tAggregate Coherence: %.4f\n', stats.Rp.CAgg)];
msg = [msg, sprintf('\tAggregate Phase:     %.4f rad\n', stats.Rp.phiAgg)];
msg = [msg, sprintf('\tCV2 (Local Var):     %.4f\n', stats.Rp.cv2)];
msg = [msg, sprintf('========================================\n')];

% Print to stdout (Command Window)
fprintf('%s', msg);

% Print to file if valid fid is provided
if fid ~= -1
    fprintf(fid, '%s', msg);
end

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{
OLD CODE:

%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%