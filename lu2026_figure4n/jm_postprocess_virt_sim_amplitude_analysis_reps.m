% jm_postprocess_virt_sim_amplitude_analysis_reps.m
%% Monte Carlo Analysis of vIRt Network Output Amplitude vs. Drive Frequency
% Usage: Run directly as a script.
% Explanation:
%       Calculates the vIRt network output amplitude as a function of drive 
%       frequency across multiple randomized batches (Monte Carlo replicates).
%       Bootstraps confidence intervals for the intrinsic and driven 
%       responses.
%
% Inputs:
%       All data files in outDir matching pattern: 'simData_vary_freq_reps_*.mat'
%           that is generated by jm_automate_virt_sim_vary_freq_reps.m
%
% Outputs:
%       Generates a figure with individual replicates, mean responses, and
%       bootstrapped confidence intervals.
%       This is Figure 4n in Lu et al 2026
%
% Requires:
%       mtspectrumc.m and dependent files from the Chronux toolbox
%       \Shared\Code\Adams_Functions\archive_dependent_scripts.m
%       \Shared\Code\vIRt-Moore\jm_virt_sim_calc_dominant_freq_spectral.m
%
% File History:
% 2025-12-12 Created by Jeff Moore
% 2026-01-09 Updated for new data set
% 2026-01-13 Reorganized and reannotated by Gemini
% 2026-01-14 Standardized file paths and parameters by Gemini
% 2026-01-14 Updated output directory to 'Figures' by Gemini
% 2026-01-15 Added backward compatibility for variable names and fields by Gemini
% 2026-01-16 Now archives dependent scripts
% 2026-01-16 Now detects input files using pattern matching
% 2026-01-16 Added natural sorting for batch files (Updated by Gemini)

%% Hard-coded parameters
% Define output directory
outDir = pwd;

% Define file pattern for data batches (assumed to be in outDir)
simDataFilePattern = 'simData_vary_freq_reps_*.mat';

% Define Chronux dependency name and relative path
nameChronuxFile = 'mtspectrumc.m';
scriptDir = fileparts(mfilename('fullpath'));
pathChronux = fullfile(scriptDir, 'chronux_2_12_annotated');

% Define output directory for figures
figureDir = fullfile(outDir, 'Figures');

% Define Chronux spectral analysis parameters
%   Note: traces are noisy with noisy inputs, need NW = 7.5 or 15
%           7.5 = 0.5 Hz resolution for 15 sec
%           15 = 1 Hz resolution for 15 sec
NW = 15;                        % Time half-bandwidth product
params.tapers = [NW, floor((2 * NW) - 1)];
params.pad    = -1;             % -1 default (no padding)
params.fpass  = [0, 15];        % Frequency pass band
params.err    = [2, 0.05];      % Error calculation [Jackknife, p-value]
params.trialave = 1;            % Average over trials

% General analysis parameters
relativeAnalysisStart = 0.5;    % When steady state starts for analysis
downsampleFactor = 10;          % Downsampling factor for spectral calculation
perVarIndex = 1;                % Select which value of perVar to use

% Bootstrap parameters
nBoot = 5000;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Preparation

% Check for Chronux and add to path
if ~exist(nameChronuxFile, 'file')
    if exist(pathChronux, 'dir')
        addpath(pathChronux);
        fprintf('%s and dependent files found and added to path.\n', nameChronuxFile);
    else
        warning('%s and dependent files not found at: %s. Spectral analysis may fail.', nameChronuxFile, pathChronux);
    end
end

% Create figure directory if it doesn't exist [2026-01-14]
if ~exist(figureDir, 'dir')
    mkdir(figureDir);
    fprintf('Created figure directory: %s\n', figureDir);
end

% Copy this script and its dependencies to the output directory
archive_dependent_scripts(mfilename, 'OutFolder', outDir);

% Initialize collections
intrinsicFreqs = [];
intrinsicAmps = [];
drivenAmps = [];

% Find all data files matching desired pattern in outDir
fileList = dir(fullfile(outDir, simDataFilePattern));
if isempty(fileList)
    error('No files found matching pattern: %s', simDataFilePattern);
end

% Extract file names into a cell array
batchFiles = {fileList.name}';

% Perform Natural Sorting
% Attempts to extract digits at the end of the filename (e.g., reps_1.mat, reps_10.mat)
tokens = regexp(batchFiles, 'reps_.*?(\d+)\.mat', 'tokens');
fileIndices = zeros(length(batchFiles), 1);
for i = 1:length(batchFiles)
    if ~isempty(tokens{i})
        % Found a number matching the specific pattern
        fileIndices(i) = str2double(tokens{i}{1}{1});
    else
        % Fallback: try finding any digit sequence in the filename
        numToken = regexp(batchFiles{i}, '(\d+)', 'tokens');
        if ~isempty(numToken)
             fileIndices(i) = str2double(numToken{end}{1});
        else
             fileIndices(i) = inf; % Push non-matching files to the end
        end
    end
end
[~, sortOrder] = sort(fileIndices);
batchFiles = batchFiles(sortOrder);

fprintf('Found %d batch files matching pattern "%s" (sorted).\n', length(batchFiles), simDataFilePattern);

%% Do the job
% --- 1. Process Batches ---
% Use batchFiles defined at top
nBatches = size(batchFiles, 1);

for iBatch = 1:nBatches
    disp(['Processing Batch ', num2str(iBatch), ': ', batchFiles{iBatch}]);
    
    % Construct full path and load data
    simDataFile = fullfile(outDir, batchFiles{iBatch});
    disp(['Loading file... ']);
    load(simDataFile);
    % Note: Loading simDataFile introduces 'output', 
    %               'testFrequencies' or 'test_frequencies',
    %               'testPerVar' or 'test_perVar' into workspace
    disp('Data file loaded!');
    
    % Backwards Compatibility: Variable Names
    if exist('test_frequencies', 'var') && ~exist('testFrequencies', 'var')
        testFrequencies = test_frequencies;
    end
    if exist('test_perVar', 'var') && ~exist('testPerVar', 'var')
        testPerVar = test_perVar;
    end

    % Validate frequency consistency between batches
    if iBatch > 1
        if ~all(testFrequencies == testFrequenciesBatch)
            error('Data files have different test frequency values');
        end
    end
    testFrequenciesBatch = testFrequencies; % Store for next iteration check
    nFreqs = length(testFrequencies);

    % Get defaults from the first batch
    if iBatch == 1
        % Extract the effector trace
        v = output.intrinsicDefault.data.effectorVec;

        % Restrict to steady state
        vss = v(ceil(end * relativeAnalysisStart):end);

        % Get the time step in seconds
        dtSeconds = output.intrinsicDefault.params.dt / 1000; 
        
        % Compute the intrinsic frequency, amplitude and set point
        [intrinsicFreqDefault, ~, ~] = ...
            jm_virt_sim_calc_dominant_freq_spectral(vss, dtSeconds, downsampleFactor, params);
        
        % Backwards Compatibility: Field Names
        if isfield(output.intrinsicDefault.analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
            intrinsicAmpDefault = output.intrinsicDefault.analysis.whisk.meanFirstPeakAmplitudeSecondHalf; 
        elseif isfield(output.intrinsicDefault.analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
            intrinsicAmpDefault = output.intrinsicDefault.analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
        else
            error('Amplitude field not found in intrinsicDefault analysis struct.');
        end
        
        % Extract the response amplitudes to all driving frequencies for the default seed
        for iFreq = 1:nFreqs
            % Backwards Compatibility: Field Names
            if isfield(output.drivenDefault.freq(iFreq).var(perVarIndex).analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
                drivenAmpDefault(iFreq) = output.drivenDefault.freq(iFreq).var(perVarIndex).analysis.whisk.meanFirstPeakAmplitudeSecondHalf;
            elseif isfield(output.drivenDefault.freq(iFreq).var(perVarIndex).analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
                drivenAmpDefault(iFreq) = output.drivenDefault.freq(iFreq).var(perVarIndex).analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
            else
                error('Amplitude field not found in drivenDefault analysis struct.');
            end
        end
    end

    % --- 2. Iterate over Replicates ---
    nReps = size(output.intrinsicRep, 2);
    for iRep = 1:nReps
        % Calculate Intrinsic properties for this replicate
        v = output.intrinsicRep(iRep).data.effectorVec;
        vss = v(ceil(end * relativeAnalysisStart):end);
        dtSeconds = output.intrinsicRep(iRep).params.dt / 1000;
        [intrinsicFreqThisRep, ~, ~] = ...
            jm_virt_sim_calc_dominant_freq_spectral(vss, dtSeconds, downsampleFactor, params);
        
        % Backwards Compatibility: Field Names
        if isfield(output.intrinsicRep(iRep).analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
            intrinsicAmpThisRep = output.intrinsicRep(iRep).analysis.whisk.meanFirstPeakAmplitudeSecondHalf;
        elseif isfield(output.intrinsicRep(iRep).analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
            intrinsicAmpThisRep = output.intrinsicRep(iRep).analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
        else
            error('Amplitude field not found in intrinsicRep analysis struct.');
        end
        
        % Calculate Driven properties for this replicate
        nPerVar = length(testPerVar);
        drivenAmpListThisRep = zeros(1, nFreqs);
        for iFreq = 1:nFreqs
             % Backwards Compatibility: Field Names
            if isfield(output.drivenRep.freq(iFreq).var(perVarIndex).rep(iRep).analysis.whisk, 'meanFirstPeakAmplitudeSecondHalf')
                drivenAmpListThisRep(iFreq) = output.drivenRep.freq(iFreq).var(perVarIndex).rep(iRep).analysis.whisk.meanFirstPeakAmplitudeSecondHalf;
            elseif isfield(output.drivenRep.freq(iFreq).var(perVarIndex).rep(iRep).analysis.whisk, 'meanFirstPeakAmplitudeToAnalyze')
                drivenAmpListThisRep(iFreq) = output.drivenRep.freq(iFreq).var(perVarIndex).rep(iRep).analysis.whisk.meanFirstPeakAmplitudeToAnalyze;
            else
                error('Amplitude field not found in drivenRep analysis struct.');
            end
        end
        
        % Append to output matrices
        intrinsicFreqs = [intrinsicFreqs; intrinsicFreqThisRep];
        intrinsicAmps = [intrinsicAmps; intrinsicAmpThisRep];
        drivenAmps = [drivenAmps; drivenAmpListThisRep];
    end
    disp('Done with batch!');
    clear output; % Free memory
end

% --- 3. Bootstrap Confidence Intervals ---
bootFun = @(x) mean(x);

% Bootstrap Intrinsic
bootMeanIntrinsicFreq = bootstrp(nBoot, bootFun, intrinsicFreqs);
bootMeanIntrinsicAmp = bootstrp(nBoot, bootFun, intrinsicAmps);
bootCiIntrinsicFreq = prctile(bootMeanIntrinsicFreq, [2.5, 97.5]);
bootCiIntrinsicAmp = prctile(bootMeanIntrinsicAmp, [2.5, 97.5]);

% Bootstrap Driven
bootMeanDrivenAmp = zeros(nBoot, nFreqs);
for iFreq = 1:nFreqs
    bootMeanDrivenAmp(:, iFreq) = bootstrp(nBoot, bootFun, drivenAmps(:, iFreq));
end
bootCiDrivenAmp = prctile(bootMeanDrivenAmp, [2.5, 97.5]);

%% Plotting
figure; hold on;

% Plot defaults (should be part of the replicates)
% plot(testFrequencies, drivenAmpDefault, 'k:');
% line(xlim, intrinsicAmpDefault * [1 1], 'Color', 'k', 'LineStyle', ':');
% line([1 1] * intrinsicFreqDefault, ylim, 'Color', 'k', 'LineStyle', ':');

% Plot replicates
plot(testFrequencies, drivenAmps, 'k.');
line(xlim, intrinsicAmps * [1 1], 'Color', 'k');
line(intrinsicFreqs * [1 1], ylim, 'Color', 'k');

% Plot bootstrap statistics
plot(testFrequencies, mean(drivenAmps), 'b.-');
plot(testFrequencies, bootCiDrivenAmp, 'b:');

% Plot Intrinsic Mean and CI
line(xlim, mean(intrinsicAmps) * [1 1], 'Color', 'b');
line(mean(intrinsicFreqs) * [1 1], ylim, 'Color', 'b');
line(xlim, bootCiIntrinsicAmp(1) * [1 1], 'Color', 'b', 'LineStyle', ':');
line(xlim, bootCiIntrinsicAmp(2) * [1 1], 'Color', 'b', 'LineStyle', ':');
line(bootCiIntrinsicFreq(1) * [1; 1], ylim, 'Color', 'b', 'LineStyle', ':');
line(bootCiIntrinsicFreq(2) * [1; 1], ylim, 'Color', 'b', 'LineStyle', ':');

xlabel('Drive frequency (Hz)');
ylabel('First whisk amplitude');

% Save figures in three formats
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_vs_drive_frequency_monte_carlo.png'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_vs_drive_frequency_monte_carlo.fig'));
saveas(gcf, fullfile(figureDir, 'fig_virt_amplitude_vs_drive_frequency_monte_carlo.eps'), 'epsc');

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{
OLD CODE:

%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%