function [timesStart, timesEnd] = create_pulse_train_times (pulseWidth, period, tMax, perVar, varargin)
%% Randomly generates start and end times for a square wave pulse train
% Usage: [timesStart, timesEnd] = create_pulse_train_times (pulseWidth, period, tMax, perVar, 'TimeFirst', 100, 'TimePreviousStart', 0)
%
% Explanation:
%       This function creates a series of pulse start and end times. The period
%       between pulses varies randomly around a specified average period with 
%       range perVar, using a uniform distribution.
%
% Example(s):
%       % Basic usage
%       [timesStart, timesEnd] = create_pulse_train_times(70, 700, 5000, 150);
%
%       % Start the pulse train at t = 500
%       [timesStart, timesEnd] = create_pulse_train_times(70, 700, 5000, 150, 'TimeFirst', 500);
%
%       % Generate a pulse train that must start after t=500, but is
%       % constrained by a previous pulse train that ended at t=100
%       [timesStart, timesEnd] = create_pulse_train_times(70, 700, 5000, 150, 'TimeFirst', 500, 'TimePreviousStart', 100);
%
%       % Generate one pulse that is allowed to go beyond tMax
%       [timesStart, timesEnd] = create_pulse_train_times(70, 700, 5000, 150, 'GenerateOneBeyond', true);
%
% Outputs:
%       timesStart  - square pulse start times
%                   specified as a numeric column vector
%       timesEnd    - square pulse end times
%                   specified as a numeric column vector
%
% Arguments:
%       pulseWidth      - square pulse width
%                       specified as a numeric scalar
%       period          - pulse train average period
%                       specified as a numeric scalar
%       tMax            - maximum time
%                       specified as a numeric scalar
%       perVar          - pulse train period variability (range)
%                       specified as a numeric scalar
%       varargin        - 'TimeFirst': initial start time of the first pulse
%                       must be a numeric scalar
%                       default == 0
%                       - 'TimePreviousStart': The start time of a previous pulse train.
%                         If passed in, the first pulse start time will be generated by
%                         repeatedly adding a randomized period to 'TimePreviousStart' 
%                         until it is greater than or equal to 'TimeFirst'.
%                       must be a numeric scalar
%                       default == NaN
%                       - 'GenerateOneBeyond': whether to generate one pulse
%                                               beyond tMax
%                       must be a logical scalar
%                       default == false
%
% Requires:
%       cd/create_error_for_nargin.m
%
% Used by:
%       \Shared\Code\vIRt\virt_moore.m

% File History:
% 2025-08-14 Pulled from virt_moore.m
% 2025-09-30 Made 'TimeFirst' an optional argument.
% 2025-10-01 Added 'TimePreviousStart' as an optional argument.
% 2025-10-01 Simplified by creating a subfunction for period generation.
% 2025-10-10 Added 'GenerateOneBeyond' as an optional argument.
% 2026-01-07 Updated annotations
% 

%% Hard-coded parameters

%% Default values for optional arguments
timeFirstDefault = 0;           % default initial pulse start time
timePreviousStartDefault = NaN;   % default end time of a previous pulse train
generateOneBeyondDefault = false; % default flag for generating one beyond tMax

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Deal with arguments
% Check number of required arguments
if nargin < 4
    error(create_error_for_nargin(mfilename));
end

% Set up Input Parser Scheme
iP = inputParser;
iP.FunctionName = mfilename;
iP.KeepUnmatched = true;                        % allow extraneous options

% Add required inputs to the Input Parser
addRequired(iP, 'pulseWidth', ...
    @(x) validateattributes(x, {'numeric'}, {'scalar'}));
addRequired(iP, 'period', ...
    @(x) validateattributes(x, {'numeric'}, {'scalar'}));
addRequired(iP, 'tMax', ...
    @(x) validateattributes(x, {'numeric'}, {'scalar'}));
addRequired(iP, 'perVar', ...
    @(x) validateattributes(x, {'numeric'}, {'scalar'}));

% Add parameter-value pairs to the Input Parser
addParameter(iP, 'TimeFirst', timeFirstDefault, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar'}));
addParameter(iP, 'TimePreviousStart', timePreviousStartDefault, ...
    @(x) validateattributes(x, {'numeric'}, {'scalar'}));
addParameter(iP, 'GenerateOneBeyond', generateOneBeyondDefault, ...
    @(x) validateattributes(x, {'logical'}, {'scalar'}));

% Read from the Input Parser
parse(iP, pulseWidth, period, tMax, perVar, varargin{:});
timeFirst = iP.Results.TimeFirst;
timePreviousStart = iP.Results.TimePreviousStart;
generateOneBeyond = iP.Results.GenerateOneBeyond;

%% Preparation
% Determine the first pulse start time
if ~isnan(timePreviousStart)
    % Generating next pulse from the last pulse of the previous pulse train
    tNow = generate_next_start(timePreviousStart, pulseWidth, period, perVar);

    % Continue to generating pulses until greater than or equal to timeFirst
    while tNow < timeFirst
        tNow = generate_next_start(tNow, pulseWidth, period, perVar);
    end
else
    % First pulse at timeFirst
    tNow = timeFirst;
end

%% Do the job
% Collect start times of square pulses
timesStart = [];

% Generate pulses as long as the end time is less than tMax
while tNow + pulseWidth < tMax
    % Add to time start
    timesStart = [timesStart; tNow];

    % Generate next time start
    tNow = generate_next_start(tNow, pulseWidth, period, perVar);
end

% Generate one more pulse if requested
if generateOneBeyond
    % Add the tNow that is out of bounds to time start
    timesStart = [timesStart; tNow];
end

% Compute end times of square pulses
timesEnd = timesStart + pulseWidth;

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function tNow = generate_next_start(tNow, pulseWidth, period, perVar)
%% Generates the next randomized period

% Generate the next period, ensuring it's at least twice the pulse width
%   period = uniform distribution between period_mean +/- 1/2 * perVar
periodNext = max(pulseWidth * 2, period + (1 - 2 * rand(1)) * (perVar / 2));

% Update next time start
tNow = tNow + periodNext;

end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%{
OLD CODE:

%}